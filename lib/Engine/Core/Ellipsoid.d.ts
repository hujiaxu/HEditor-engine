import Cartesian3 from './Cartesian3';
import Cartographic from './Cartographic';
export default class Ellipsoid {
    x: number;
    y: number;
    z: number;
    private _radii;
    private _radiiSquared;
    private _radiiToTheFourth;
    private _oneOverRadii;
    private _oneOverRadiiSquared;
    private _minimumRadius;
    private _maximumRadius;
    private _centerToleranceSquared;
    private _squaredXOverSquaredZ;
    static WGS84: Ellipsoid;
    static UNIT_SPHERE: Ellipsoid;
    static MOON: Ellipsoid;
    static default: Ellipsoid;
    static clone: (ellipsoid: Ellipsoid, result?: Ellipsoid) => Ellipsoid;
    static fromCartesian3: (cartesian: Cartesian3, result?: Ellipsoid) => Ellipsoid;
    get radii(): Cartesian3;
    get radiiSquared(): Cartesian3;
    get radiiToTheFourth(): Cartesian3;
    get oneOverRadii(): Cartesian3;
    get oneOverRadiiSquared(): Cartesian3;
    get minimumRadius(): number;
    get maximumRadius(): number;
    get centerToleranceSquared(): number;
    get squaredXOverSquaredZ(): number;
    constructor(x?: number, y?: number, z?: number);
    reinitialize(x: number, y: number, z: number): void;
    private _initialize;
    geodeticSurfaceNormal(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
    equals(right: Ellipsoid): boolean;
    scaleToGeodeticSurface(cartesian: Cartesian3, result?: Cartesian3): Cartesian3 | undefined;
    cartesianToCartographic(cartesian: Cartesian3, result?: Cartographic): Cartographic;
    geodeticSurfaceNormalCartogrphic(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
    cartographicToCartesian(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
    transformPositionToScaledSpace(position: Cartesian3, result?: Cartesian3): Cartesian3;
}
